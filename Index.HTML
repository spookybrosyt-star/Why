<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PAISER ESCAPE: SMART AI</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Orbitron', sans-serif; 
            touch-action: none; user-select: none; -webkit-user-select: none;
        }

        /* --- UI LAYER --- */
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        /* HUD ELEMENTS */
        .hud-panel { position: absolute; padding: 10px; text-shadow: 2px 2px 0 #000; }
        #top-left { top: 20px; left: 20px; }
        #top-center { top: 20px; left: 50%; transform: translateX(-50%); text-align: center; }

        .stat-label { font-size: 14px; color: #888; display: block; margin-bottom: 5px; }
        .stat-value { font-size: 24px; color: #fff; font-weight: bold; }

        #stamina-container {
            width: 200px; height: 10px; background: #333; border: 2px solid #555; border-radius: 5px; overflow: hidden; margin-top: 5px;
        }
        #stamina-bar { width: 100%; height: 100%; background: #00ff00; transition: width 0.1s; }

        #danger-msg { color: #ff0000; font-size: 18px; display: none; animation: pulse 0.5s infinite alternate; }
        @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(5px);
            z-index: 50; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; color: white; text-align: center; pointer-events: auto;
        }
        h1 { font-size: 40px; color: #ff3333; margin: 0 0 10px 0; }
        p { color: #ccc; max-width: 80%; }
        
        .btn {
            background: #ff3333; color: white; border: none; padding: 20px 50px;
            font-size: 20px; font-family: 'Orbitron', sans-serif; font-weight: bold;
            margin-top: 30px; cursor: pointer; border-radius: 5px;
        }
        .btn:active { background: #cc0000; }

        /* CONTROLS */
        #controls-zone { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; display: flex; }
        #left-zone { width: 50%; height: 100%; }
        #right-zone { width: 50%; height: 100%; }

        #joystick-base {
            position: absolute; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; display: none; pointer-events: none; z-index: 6;
        }
        #joystick-knob {
            position: absolute; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        #jumpscare-img { width: 300px; height: 300px; object-fit: cover; border: 5px solid red; display: none; margin-bottom: 20px; }
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1>Paiser Escape</h1>
        <p>INTELLIGENCE LEVEL: <span style="color:red">MAXIMUM</span></p>
        <p>He knows where you are. He will find the shortest path.</p>
        <button class="btn" onclick="startGame()">START</button>
    </div>

    <div id="game-over-screen" class="screen" style="display: none;">
        <img id="jumpscare-img" src="https://i.postimg.cc/MKwNCKtC/IMG-0121.jpg">
        <h1>CAUGHT</h1>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>

    <div id="game-ui">
        <div id="top-left" class="hud-panel">
            <span class="stat-label">STAMINA</span>
            <div id="stamina-container"><div id="stamina-bar"></div></div>
        </div>
        <div id="top-center" class="hud-panel">
            <div id="danger-msg">⚠ HUNTING ⚠</div>
            <span class="stat-label">DISTANCE</span>
            <span id="dist-val" class="stat-value">--m</span>
        </div>
    </div>

    <div id="controls-zone">
        <div id="left-zone"></div>
        <div id="right-zone"></div>
    </div>
    <div id="joystick-base"><div id="joystick-knob"></div></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const CONFIG = {
            CELL_SIZE: 25,     
            WALL_HEIGHT: 18,
            MAZE_SIZE: 21,
            WALK_SPEED: 45.0,
            RUN_SPEED: 95.0,
            ENEMY_SPEED: 52.0, // High speed + Pathfinding = Deadly
            IMAGE_URL: 'https://i.postimg.cc/MKwNCKtC/IMG-0121.jpg'
        };

        // --- GLOBALS ---
        let camera, scene, renderer;
        let walls = []; // Mesh array for player collision
        let mazeGrid = []; // 0=Empty, 1=Wall (For AI)
        let enemy;
        let enemyPath = []; // Array of Vector3 waypoints
        let pathTimer = 0;
        
        let isGameRunning = false;
        let lastTime = performance.now();
        let input = { fwd: 0, right: 0 };
        let stamina = 100;
        let camRotX = 0, camRotY = 0;
        let enemyTexture;

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x000000, 0.025);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const flashlight = new THREE.SpotLight(0xffffff, 2.5, 120, 0.6, 0.5, 1);
            flashlight.position.set(0,0,0);
            camera.add(flashlight);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            new THREE.TextureLoader().load(CONFIG.IMAGE_URL, (tex) => {
                enemyTexture = tex;
                enemyTexture.colorSpace = THREE.SRGBColorSpace;
            });

            generateMaze();
            setupTouch();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        // --- MAZE & AI ---
        function generateMaze() {
            walls.forEach(w => scene.remove(w));
            walls = [];
            
            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000), 
                new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI/2;
            scene.add(floor);

            const wallGeo = new THREE.BoxGeometry(CONFIG.CELL_SIZE, CONFIG.WALL_HEIGHT, CONFIG.CELL_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x5a3e2b });

            // Initialize Grid
            const size = CONFIG.MAZE_SIZE;
            mazeGrid = Array(size).fill().map(() => Array(size).fill(1)); // 1 = Wall

            // Recursive Backtracker
            const startX = 1, startY = 1;
            mazeGrid[startX][startY] = 0; // 0 = Path
            const stack = [[startX, startY]];
            
            while(stack.length) {
                const [cx, cy] = stack[stack.length-1];
                const dirs = [[0,-2], [0,2], [-2,0], [2,0]].sort(() => Math.random()-0.5);
                let found = false;
                for(let [dx, dy] of dirs) {
                    const nx = cx+dx, ny = cy+dy;
                    if(nx>0 && nx<size-1 && ny>0 && ny<size-1 && mazeGrid[nx][ny]===1) {
                        mazeGrid[cx+dx/2][cy+dy/2] = 0;
                        mazeGrid[nx][ny] = 0;
                        stack.push([nx,ny]);
                        found = true;
                        break;
                    }
                }
                if(!found) stack.pop();
            }

            // Build 3D World from Grid
            const offset = (size * CONFIG.CELL_SIZE) / 2;
            for(let x=0; x<size; x++) {
                for(let y=0; y<size; y++) {
                    if(mazeGrid[x][y] === 1) {
                        const w = new THREE.Mesh(wallGeo, wallMat);
                        w.position.set(x*CONFIG.CELL_SIZE - offset, CONFIG.WALL_HEIGHT/2, y*CONFIG.CELL_SIZE - offset);
                        scene.add(w);
                        walls.push(w);
                    }
                }
            }
        }

        // --- A* PATHFINDING ALGORITHM ---
        function findPath(startPos, endPos) {
            // Convert World Coords to Grid Coords
            const size = CONFIG.MAZE_SIZE;
            const offset = (size * CONFIG.CELL_SIZE) / 2;

            const gridX1 = Math.round((startPos.x + offset) / CONFIG.CELL_SIZE);
            const gridY1 = Math.round((startPos.z + offset) / CONFIG.CELL_SIZE);
            const gridX2 = Math.round((endPos.x + offset) / CONFIG.CELL_SIZE);
            const gridY2 = Math.round((endPos.z + offset) / CONFIG.CELL_SIZE);

            // Boundaries check
            if(gridX1 < 0 || gridX1 >= size || gridY1 < 0 || gridY1 >= size) return null;
            if(gridX2 < 0 || gridX2 >= size || gridY2 < 0 || gridY2 >= size) return null;

            // A* Structures
            const openSet = [];
            const cameFrom = {}; // Map node -> parent
            const gScore = {};
            const fScore = {};

            const startNode = `${gridX1},${gridY1}`;
            const endNode = `${gridX2},${gridY2}`;

            openSet.push(startNode);
            gScore[startNode] = 0;
            fScore[startNode] = Math.abs(gridX1-gridX2) + Math.abs(gridY1-gridY2); // Heuristic

            while(openSet.length > 0) {
                // Get node with lowest fScore
                let current = openSet[0];
                let lowestIndex = 0;
                for(let i=1; i<openSet.length; i++) {
                    if((fScore[openSet[i]] || Infinity) < (fScore[current] || Infinity)) {
                        current = openSet[i];
                        lowestIndex = i;
                    }
                }

                if(current === endNode) {
                    return reconstructPath(cameFrom, current, offset);
                }

                openSet.splice(lowestIndex, 1);
                
                const [cx, cy] = current.split(',').map(Number);
                
                // Neighbors (Up, Down, Left, Right)
                const neighbors = [
                    [cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]
                ];

                for(let [nx, ny] of neighbors) {
                    // Check bounds and walls
                    if(nx >= 0 && nx < size && ny >= 0 && ny < size && mazeGrid[nx][ny] === 0) {
                        const neighbor = `${nx},${ny}`;
                        const tentativeG = gScore[current] + 1;

                        if(tentativeG < (gScore[neighbor] || Infinity)) {
                            cameFrom[neighbor] = current;
                            gScore[neighbor] = tentativeG;
                            fScore[neighbor] = gScore[neighbor] + (Math.abs(nx-gridX2) + Math.abs(ny-gridY2));
                            
                            if(!openSet.includes(neighbor)) {
                                openSet.push(neighbor);
                            }
                        }
                    }
                }
            }
            return null; // No path found
        }

        function reconstructPath(cameFrom, current, offset) {
            const totalPath = [];
            while(current in cameFrom) {
                const [gx, gy] = current.split(',').map(Number);
                // Convert back to World Space
                totalPath.unshift(new THREE.Vector3(
                    gx * CONFIG.CELL_SIZE - offset,
                    5, // Enemy height
                    gy * CONFIG.CELL_SIZE - offset
                ));
                current = cameFrom[current];
            }
            return totalPath;
        }

        // --- GAME LOGIC ---
        function createEnemy() {
            if(enemy) scene.remove(enemy);
            const mat = new THREE.SpriteMaterial({ 
                map: enemyTexture || new THREE.CanvasTexture(document.createElement('canvas')),
                color: enemyTexture ? 0xffffff : 0xff0000 
            });
            enemy = new THREE.Sprite(mat);
            enemy.scale.set(12, 14, 1);
            
            // Spawn far
            const offset = (CONFIG.MAZE_SIZE * CONFIG.CELL_SIZE) / 2;
            enemy.position.set((CONFIG.MAZE_SIZE-2)*CONFIG.CELL_SIZE - offset, 6, (CONFIG.MAZE_SIZE-2)*CONFIG.CELL_SIZE - offset);
            scene.add(enemy);
            enemyPath = [];
        }

        function checkCollision(pos, radius) {
            const wallHalf = CONFIG.CELL_SIZE / 2; 
            for(let w of walls) {
                if(Math.abs(pos.x - w.position.x) > CONFIG.CELL_SIZE) continue;
                if(Math.abs(pos.z - w.position.z) > CONFIG.CELL_SIZE) continue;
                if (Math.abs(pos.x - w.position.x) < (wallHalf + radius) && 
                    Math.abs(pos.z - w.position.z) < (wallHalf + radius)) return true;
            }
            return false;
        }

        window.startGame = () => {
            document.getElementById('start-screen').style.display = 'none';
            if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{});
            resetGameLogic();
        };

        window.resetGame = () => {
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('game-ui').style.display = 'block';
            resetGameLogic();
        };

        function resetGameLogic() {
            const offset = (CONFIG.MAZE_SIZE * CONFIG.CELL_SIZE) / 2;
            camera.position.set(CONFIG.CELL_SIZE - offset, 6, CONFIG.CELL_SIZE - offset);
            camRotX = 0; camRotY = 0;
            stamina = 100;
            createEnemy();
            isGameRunning = true;
            document.getElementById('jumpscare-img').style.display = 'none';
        }

        function setupTouch() {
            const left = document.getElementById('left-zone');
            const right = document.getElementById('right-zone');
            const stick = document.getElementById('joystick-base');
            const knob = document.getElementById('joystick-knob');
            let startX, startY;

            left.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.changedTouches[0];
                startX = t.clientX; startY = t.clientY;
                stick.style.display = 'block';
                stick.style.left = (startX - 60) + 'px';
                stick.style.top = (startY - 60) + 'px';
                knob.style.transform = `translate(-50%, -50%)`;
            }, {passive:false});

            left.addEventListener('touchmove', e => {
                e.preventDefault();
                const t = e.changedTouches[0];
                const dx = t.clientX - startX, dy = t.clientY - startY;
                const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
                const angle = Math.atan2(dy, dx);
                knob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                input.right = (Math.cos(angle)*dist)/50;
                input.fwd = -(Math.sin(angle)*dist)/50;
            }, {passive:false});

            const endStick = (e) => { e.preventDefault(); stick.style.display = 'none'; input.fwd = 0; input.right = 0; };
            left.addEventListener('touchend', endStick); left.addEventListener('touchcancel', endStick);

            let lx, ly;
            right.addEventListener('touchstart', e => { lx = e.changedTouches[0].clientX; ly = e.changedTouches[0].clientY; }, {passive:false});
            right.addEventListener('touchmove', e => {
                e.preventDefault();
                const t = e.changedTouches[0];
                camRotY -= (t.clientX - lx) * 0.005;
                camRotX = Math.max(-1.5, Math.min(1.5, camRotX - (t.clientY - ly) * 0.005));
                lx = t.clientX; ly = t.clientY;
            }, {passive:false});
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isGameRunning) { renderer.render(scene, camera); return; }

            const time = performance.now();
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // --- PLAYER ---
            const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(camRotX, camRotY, 0, 'YXZ'));
            camera.quaternion.copy(q);

            const isSprinting = input.fwd > 0.8 && stamina > 0;
            const speed = isSprinting ? CONFIG.RUN_SPEED : CONFIG.WALK_SPEED;
            if(isSprinting) stamina -= 25*dt; else { stamina += 15*dt; if(stamina>100)stamina=100; }
            document.getElementById('stamina-bar').style.width = stamina + '%';
            document.getElementById('stamina-bar').style.background = isSprinting ? '#ffff00' : '#00ff00';

            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y=0; fwd.normalize();
            const rgt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); rgt.y=0; rgt.normalize();
            const move = new THREE.Vector3().addScaledVector(fwd, input.fwd*speed*dt).addScaledVector(rgt, input.right*speed*dt);

            if(!checkCollision(new THREE.Vector3(camera.position.x+move.x, 6, camera.position.z), 4)) camera.position.x += move.x;
            if(!checkCollision(new THREE.Vector3(camera.position.x, 6, camera.position.z+move.z), 4)) camera.position.z += move.z;

            // --- SMART ENEMY AI ---
            if(enemy) {
                // Update Pathfinding every 0.3 seconds
                pathTimer += dt;
                if(pathTimer > 0.3) {
                    pathTimer = 0;
                    const path = findPath(enemy.position, camera.position);
                    if(path && path.length > 0) enemyPath = path;
                }

                // Determine Target
                let targetPos = camera.position.clone(); // Default: Run at player
                
                // If we have a path, target the first waypoint
                if(enemyPath.length > 0) {
                    const waypoint = enemyPath[0];
                    targetPos = waypoint.clone();
                    
                    // If close to waypoint, remove it and go to next
                    if(enemy.position.distanceTo(waypoint) < 5) {
                        enemyPath.shift();
                    }
                }

                const dir = new THREE.Vector3().subVectors(targetPos, enemy.position);
                dir.y = 0; 
                dir.normalize();
                
                // Move Enemy
                const step = CONFIG.ENEMY_SPEED * dt;
                enemy.position.addScaledVector(dir, step);

                // Game Over Check
                const dist = camera.position.distanceTo(enemy.position);
                document.getElementById('dist-val').innerText = Math.floor(dist) + 'm';
                document.getElementById('danger-msg').style.display = dist < 40 ? 'block' : 'none';

                if(dist < 5) {
                    isGameRunning = false;
                    document.getElementById('game-ui').style.display = 'none';
                    document.getElementById('game-over-screen').style.display = 'flex';
                    document.getElementById('jumpscare-img').style.display = 'block';
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
